[Lifecycle Stages](http://courses.cs.washington.edu/courses/cse403/14sp/lectures/lecture02-lifecycle.pdf
)

* Problem definition
* Requirements specification
* Design
* Coding
* Integration
* Testing
* Deployment
* Maintenance

Mix-and-match and loop to create your own methodology

**Evaluation**: risk reduction,satisfying customer, quality,visible progress, cost control,predictability

* code-and-fix: write some code, debug it, repeat (i.e., ad-hoc)
* waterfall: standard phases (req., design, code, test) in order
* spiral: assess risks at each step; do most critical action first
* evolutionary prototyping: build an initial small requirement spec, code it, then "evolve" the spec and code as needed
* staged delivery: build initial requirement specs for several releases, then design-and-code each in sequence.

Benefits of using a lifecycle

* It provides us with a structure in which to work
* It forces us to think of the “big picture” and follow steps so that we reach it without glaring deficiencies
* Without it you may make decisions that are  individually on target but collectively  misdirected
* It is a management tool

But, 
* Can lead to compromises and artificial constraints
* Risk of overemphasizing process (not the end in itself)

Sequential methods when... (From Code Complete second edition)

* Requirements are fairly stable
* Design is straightforward and fairly well understood
* Development team familiar with application area
* Project contains little risk
* Cost of changing requirements design and code downstream is high

Iterative methods when...

* Requirements not well understood or expected to be unstable
* Design is complex, challenging, or both
* Developer team unfamiliar with application area
* Project contains a lot of risk, and uncertainty
* Long-term predictability not important
* Cost changing requirements, design, code likely to be low