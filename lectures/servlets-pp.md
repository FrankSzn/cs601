Java Servlets
====

# Big picture

A _servlet_ is a piece of Java code that runs on the server in response to a browser request.  Servlets support the request/response client/server model and are able to service HTTP `GET` and `POST` requests.  They are a replacement for CGI bin and php etc...

Many dynamic pages on the net are generated by Java code on a server and spit back to the browser, which can pretend that everything is a static file.

Servlets can be used to create services or generate HTML pages. These HTML pages can be a bunch of HTML or HTML plus JavaScript.

The trend these days is towards so-called *single-page apps* where a single page comes back from the server and the user moves around within that page interactively; i.e., the URL of the browser does not change. There are good and bad things about this, which we'll discuss later.

For now, let's assume that we have one servlet execute for each page request that sends back appropriate data or an HTML page (to a browser).

# JSP

What is _JSP_?  Java Server Pages are "inside out" servlets where, instead of Java with embedded print HTML statements, you have HTML with embedded Java code snippets. We will not be discussing JSP as it has mostly fallen out of favor.

## Main?

Where is the `main` method in a server?  For most deployed applications, there isn't one.  The first execution of one of your pages must launch the application initiation procedures.  In our case, you will be launching Jetty, the web server, from a main method so you could in principle do whatever initialization you wanted before the first page is served.

## Maintaining client/server state

HTTP is stateless.  How can your server know when the same person comes back to the site? That is, when I click on a link on a site that takes me to another page on the same site, how does the server know that a particular GET request is from the same person?  Further, how does the server track a chunk of data for each person logged into the site?  For example, you want to track their name, ID, and pages visited perhaps.  _Sessions_ are used for that and we will worry about them in another lecture.  But they exist, and every servlet can ask for a site visitor's session object across pages.  These sessions are normally implemented via _cookies_, little pieces of key/value pair data stored on a person's client machine.  Each request to site foo.com sends all foo.com cookies on the client machine to the server along with each GET/POST request.

#### Some details

See [Servlet package doc](http://java.sun.com/products/servlet/2.3/javadoc/index.html)

Useful class summary:

*       HttpServlet,
*       HttpServletRequest, 
*       HttpServletResponse,
*       HttpSession, 
*       Cookie, 
*       URLEncoder, 
*       java.netURLEncoder.encode(...).

Servlets generate data or HTML that is sent back to a client or browser.

Servlets associated with HTTP have the `Http` prefix.

http servlets have methods are associated with the http protocol. GET, POST, etc...  The HTTP `GET` request invokes `doGet()` method.

The servlet life cycle:

1. init
1. service many times (doGet/doPost in our case)
1. destroy

One instance of a servlet per server.  Watch out for threading issues.  Can tell it to be singlethreaded, but very slow.  Reference example of using instance vars setting/getting from within service.

Later we'll talk about generating html properly and can discuss in detail.

How do they work?  Unfortunately that really depends on the servlet _container_ you are using.  A container is really just the Web server that executes your job in response to a URL.

Some containers let you place your .java file inside a special directory and your server will be able to send URL requests to that code.  The HTTP server compiles the code for you (and can replace an old one on a running server).  With Jetty, it will find your servlet code from the CLASSPATH so make sure you start your app with the path set to see both jetty stuff and your stuff.

A servlet runs in the same address space as the server and typically represents a middle tier in a three tier system.

# Jetty

[Jetty](http://www.eclipse.org/jetty/) is a simple embeddable or standalone web server for static pages or dynamic pages like JSP or Servlets.  For our purposes, it's probably easier to have your application embed the web server directly.

[Download jetty-9](http://download.eclipse.org/jetty/stable-9/dist/) and then:

```bash
$ mv jetty-distribution-9.2.3.v20140905/lib /usr/local/lib/jetty-9.2.3
```

[Embedding Jetty](http://www.eclipse.org/jetty/documentation/current/embedding-jetty.html)

[Example source](https://github.com/parrt/cs601/tree/master/lectures/code/web)

The biggest issue will be getting the class path right:

```bash
$ j -cp ".:/usr/local/lib/jetty-9.2.3/*" OneHandler
2014-09-24 12:20:14.823:INFO::main: Logging initialized @59ms
2014-09-24 12:20:14.859:INFO:oejs.Server:main: jetty-9.2.3.v20140905
2014-09-24 12:20:14.895:INFO:oejs.ServerConnector:main: Started ServerConnector@d3cb1cb{HTTP/1.1}{0.0.0.0:8080}
2014-09-24 12:20:14.896:INFO:oejs.Server:main: Started @159ms
...
```

## Simple file serving

Here is a simple program that starts up a web server at port 8080 and has a document root specified by args[0]:

```java
import org.mortbay.http.*;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.servlet.*;
import org.mortbay.log.*;

public class MyServer {
    public static void main(String[] args) throws Exception {
	String DOC_ROOT = args[0];
        Server server = new Server();
        server.addListener(":8080");
        server.setRequestLog(getServerLogging());
        server.addWebApplication("/", DOC_ROOT);
        server.start();
    }
}
```

You will need the following additions to your `CLASSPATH`:

```java
/home/public/cs601/jetty/javax.servlet.jar
/home/public/cs601/jetty/org.mortbay.jetty.jar
/home/public/cs601/jetty/log4j-1.2.12.jar
/home/public/cs601/jetty/jasper-compiler.jar
/home/public/cs601/jetty/jasper-runtime.jar
/home/public/cs601/jetty/xercesImpl.jar
/home/public/cs601/jetty/commons-logging.jar
```

which are the jars used by Jetty.  Start your server like this:

```java
java MyServer ~/foo
```

which will start serving files underneath `~/foo`.  URLs like _host_`:8080/t.html` will get file `~/foo/t.html` from the disk.

At this point, Jetty will serve files, but you are not recording requests to your server.  Add the following method:

```java
private static RequestLog getServerLogging() throws Exception {
    NCSARequestLog a = new NCSARequestLog("./request.log");
    a.setRetainDays(90);
    a.setAppend(true);
    a.setExtended(false);
    a.setLogTimeZone("GMT");
    a.start();
    return a;
`   
```

And add this line before the server.start():

```java
server.setRequestLog(getServerLogging());
```

You still get a warning from Jetty, but ignore it:

```java
log4j:WARN No appenders could be found for logger (org.mortbay.util.Container).
log4j:WARN Please initialize the log4j system properly.
```

## GET

Note that the servlet receives a request and response object.  The request object contains information about the HTTP request, plus parameters, and other header info.  The response object lets you set response headers, cookies, and lets you write to the output stream.

```java
!include "../code/servlets/HelloServlet.java"
```

## POST

Used as target of form processing.  Can handle much more data (I think) in terms of parameters.  `request.getParameter` is used to get URL parameters.

```html
<html>
<body>
<FORM METHOD=POST ACTION="/servlet/SimpleResponse">
<input type=text size=45 name=query value="type your query here">
<input type=submit value=SEARCH>
</FORM>
</body>
</html>
```

Servlet responding to form (note both `doGet` and `doPost` methods):

!include "../code/servlets/SimpleResponse.java"

Use HttpUtils.getRequestURL(request) to reconstruct URL minus query (args).

Other useful methods in: [getRemoteHost()](http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getRemoteHost())



### Serving Servlets

To get Jetty to handle servlets, update your server code to look like this:

```java
Server server = new Server();
server.addListener(":8080");

// logging
server.setRequestLog(getServerLogging());

// Servlets
ServletHttpContext context = 
    (ServletHttpContext) server.getContext("/");
context.addServlet("Invoker","/servlet/*",
       "org.mortbay.jetty.servlet.Invoker");

// HTTP
server.addWebApplication("/", "./");

server.start();
```

Servlet `HelloServlet` would be visible at _host_`:8080/servlet/HelloServlet`.



# Thread safety

The safety issue for servlets with instance variables can be illustrated with the following:

```java
class PageServlet extends HttpServer {
    String id;
    public void doGet(HttpServletRequest request,
          HttpServletResponse response)
    throws ServletException, IOException
    {
        id = request.getParameter("ID");
        ...
        out.println("Your id is "+id);
    }
    ...
}
```

One thread can set the id then switch to another thread which resets id.  When that second thread finishes the first thread would start up and proceed to print out the same value as the second thread.  I.e., if url s?ID=1 and s?ID=2 result in simultaneous exec of this servlet, you risk seeing the same id value printed out.

# File Uploads

Can do file uploads with http servers.  The HTML POST action looks like:

```html
<FORM METHOD=POST ACTION="/submit/process" ENCTYPE="multipart/form-data">
...
</FORM>
```

# Argument URL encoding

Converts meaningful or special chars to ascii code.

`' '->%20` etc....

Use:  `java.netURLEncoder.encode(...)`

Here is an example calling the doGet method using a space in arg.

http://localhost:8080/servlet/SimpleResponse?name=Terence%20Parr

