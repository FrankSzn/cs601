Java Servlets
====

# Big picture

A _servlet_ is a piece of Java code that runs on the server in response to a browser request.  Servlets support the request/response client/server model and are able to service HTTP `GET` and `POST` requests.  They are a replacement for CGI bin and php etc...

Many dynamic pages on the net are generated by Java code on a server and spit back to the browser, which can pretend that everything is a static file.

Servlets can be used to create services or generate HTML pages. These HTML pages can be a bunch of HTML or HTML plus JavaScript.

The trend these days is towards so-called *single-page apps* where a single page comes back from the server and the user moves around within that page interactively; i.e., the URL of the browser does not change. There are good and bad things about this, which we'll discuss later.

For now, let's assume that we have one servlet execute for each page request that sends back appropriate data or an HTML page (to a browser).

# JSP

What is _JSP_?  Java Server Pages are "inside out" servlets where, instead of Java with embedded print HTML statements, you have HTML with embedded Java code snippets. We will not be discussing JSP as it has mostly fallen out of favor.

## Main?

Where is the `main` method in a server?  For most deployed applications, there isn't one.  The first execution of one of your pages must launch the application initiation procedures.  In our case, you will be launching Jetty, the web server, from a main method so you could in principle do whatever initialization you wanted before the first page is served.

## Maintaining client/server state

HTTP is stateless.  How can your server know when the same person comes back to the site? That is, when I click on a link on a site that takes me to another page on the same site, how does the server know that a particular GET request is from the same person?  Further, how does the server track a chunk of data for each person logged into the site?  For example, you want to track their name, ID, and pages visited perhaps.  _Sessions_ are used for that and we will worry about them in another lecture.  But they exist, and every servlet can ask for a site visitor's session object across pages.  These sessions are normally implemented via _cookies_, little pieces of key/value pair data stored on a person's client machine.  Each request to site foo.com sends all foo.com cookies on the client machine to the server along with each GET/POST request.

#### Some details

See [Servlet package doc](http://java.sun.com/products/servlet/2.3/javadoc/index.html)

Useful class summary:

*       HttpServlet,
*       HttpServletRequest, 
*       HttpServletResponse,
*       HttpSession, 
*       Cookie, 
*       URLEncoder, 
*       java.netURLEncoder.encode(...).

Servlets generate data or HTML that is sent back to a client or browser.

Servlets associated with HTTP have the `Http` prefix.

http servlets have methods are associated with the http protocol. GET, POST, etc...  The HTTP `GET` request invokes `doGet()` method.

The servlet life cycle:

1. init
1. service many times (doGet/doPost in our case)
1. destroy

One instance of a servlet per server.  Watch out for threading issues.  Can tell it to be singlethreaded, but very slow.  Reference example of using instance vars setting/getting from within service.

Later we'll talk about generating html properly and can discuss in detail.

How do they work?  Unfortunately that really depends on the servlet _container_ you are using.  A container is really just the Web server that executes your job in response to a URL.

Some containers let you place your .java file inside a special directory and your server will be able to send URL requests to that code.  The HTTP server compiles the code for you (and can replace an old one on a running server).  With Jetty, it will find your servlet code from the CLASSPATH so make sure you start your app with the path set to see both jetty stuff and your stuff.

A servlet runs in the same address space as the server and typically represents a middle tier in a three tier system.

# Jetty

[Jetty](http://www.eclipse.org/jetty/) is a simple embeddable or standalone web server for static pages or dynamic pages like JSP or Servlets.  For our purposes, it's probably easier to have your application embed the web server directly.

[Download jetty-9](http://download.eclipse.org/jetty/stable-9/dist/) and then:

```bash
$ mv jetty-distribution-9.2.3.v20140905/lib /usr/local/lib/jetty-9.2.3
```

[Embedding Jetty](http://www.eclipse.org/jetty/documentation/current/embedding-jetty.html)

[Example source](https://github.com/parrt/cs601/tree/master/lectures/code/web)

## Handlers

As a first example, let's get a piece of code to respond to a URL request. It is not specifically a servlet, but rather a generic `Handler`  with a `handle()` method. We can put whatever we want in that method. We generate output with:

```java
response.getWriter().println("hello");
```

Jetty says:

<blockquote>
To produce a response to a request, Jetty requires that you set a Handler on the server. A handler may:

<ul>
<li>Examine/modify the HTTP request.

<li>Generate the complete HTTP response.

<li>Call another Handler (see HandlerWrapper).

<li>Select one or many Handlers to call (see HandlerCollection).
</ul>
</blockquote>

These handlers are a jetty concept which is fine to get us started but we will generally be using Servlets because that is a portable Java mechanism that would work in, say, tomcat. Servlets have the notion of sessions, which we will talk about later, that preserves state between HTTP requests. Handlers don't have that by default.

[Handlers vs Servlets](http://stackoverflow.com/questions/4163553/jetty-servlets-vs-handlers).

## A first example

Here is the startup code that launches a socket handler:

```java
// Derived from:
// http://download.eclipse.org/jetty/stable-9/xref/org/eclipse/jetty/embedded/FileServer.html
// Copyright (c) 1995-2014 Mort Bay Consulting Pty. Ltd.
// Released under Eclipse Public License v1.0 and Apache License v2.0

import org.eclipse.jetty.server.Server;

public class OneHandler
{
    public static void main(String[] args) throws Exception
    {
        Server server = new Server(8080);
        server.setHandler(new HelloHandler());

        server.start();
        server.join();
    }
}
```

and then a `Handler`:

```java
// Derived from:
// http://download.eclipse.org/jetty/stable-9/xref/org/eclipse/jetty/embedded/FileServer.html
// Copyright (c) 1995-2014 Mort Bay Consulting Pty. Ltd.
// Released under Eclipse Public License v1.0 and Apache License v2.0

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.eclipse.jetty.server.Request;
import org.eclipse.jetty.server.handler.AbstractHandler;

public class HelloHandler extends AbstractHandler
{
    final String _greeting;
    final String _body;

    public HelloHandler()
    {
        _greeting="Hello World";
        _body=null;
    }

    public HelloHandler(String greeting)
    {
        _greeting=greeting;
        _body=null;
    }

    public HelloHandler(String greeting,String body)
    {
        _greeting=greeting;
        _body=body;
    }

    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
    {
        response.setContentType("text/html;charset=utf-8");
        response.setStatus(HttpServletResponse.SC_OK);
        baseRequest.setHandled(true);

        response.getWriter().println("<h1>"+_greeting+"</h1>");
        if (_body!=null)
            response.getWriter().println(_body);
    }
}
```

The biggest issue will be getting the class path right:

```bash
$ j -cp ".:/usr/local/lib/jetty-9.2.3/*" OneHandler
2014-09-24 12:20:14.823:INFO::main: Logging initialized @59ms
2014-09-24 12:20:14.859:INFO:oejs.Server:main: jetty-9.2.3.v20140905
2014-09-24 12:20:14.895:INFO:oejs.ServerConnector:main: Started ServerConnector@d3cb1cb{HTTP/1.1}{0.0.0.0:8080}
2014-09-24 12:20:14.896:INFO:oejs.Server:main: Started @159ms
...
```

Once that starts up, go to `http://localhost:8080/` in your browser and it should show you `Hello World`.

A handler is a generic bit of code that Jetty knows how to run. Servlets are based on these handlers.

## Simple file server

Here is a simple program that starts up a web server at port 8080 and has a document root of the current directory:

```java
// Derived from:
// http://download.eclipse.org/jetty/stable-9/xref/org/eclipse/jetty/embedded/FileServer.html
// Copyright (c) 1995-2014 Mort Bay Consulting Pty. Ltd.
// Released under Eclipse Public License v1.0 and Apache License v2.0

import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.handler.DefaultHandler;
import org.eclipse.jetty.server.handler.HandlerList;
import org.eclipse.jetty.server.handler.ResourceHandler;

public class FileServer {
    public static void main(String[] args) throws Exception {
        Server server = new Server(8080);
        ResourceHandler resource_handler = new ResourceHandler();
        resource_handler.setDirectoriesListed(true);
		resource_handler.setResourceBase(".");                    // must set root dir

        HandlerList handlers = new HandlerList();
        handlers.setHandlers(new Handler[] { resource_handler, 	  // file handler
											 new DefaultHandler() // handles 404 etc...
		});
        server.setHandler(handlers);

        server.start();
        server.join();
    }

}
```

Start your server like this:

```java
$ java -cp ".:/usr/local/lib/jetty-9.2.3/*" FileServer
```

http://localhost:8080/FileServer.java

which will start serving files underneath whatever the working directory is when you launch it. If you start it from the directory containing the code itself, you can use URL

`http://localhost:8080/FileServer.java`

to display the Java code.

## Logging

At this point, Jetty will serve files, but you are not recording requests to your server. We need a small tweaks to the server startup:

```java
Server server = new Server(8080);
HandlerCollection handlers = new HandlerCollection();
server.setHandler(handlers);

ServletHandler servlet = new ServletHandler();
servlet.addServletWithMapping(HelloServlet.class, "/*");
handlers.addHandler(servlet);

handlers.addHandler(new DefaultHandler()); // must be after servlet it seems
```

and then we add the following code:

```java
// log using NCSA (common log format)
// http://en.wikipedia.org/wiki/Common_Log_Format
NCSARequestLog requestLog = new NCSARequestLog();
requestLog.setFilename("/tmp/yyyy_mm_dd.request.log");
requestLog.setFilenameDateFormat("yyyy_MM_dd");
requestLog.setRetainDays(90);
requestLog.setAppend(true);
requestLog.setExtended(true);
requestLog.setLogCookies(false);
requestLog.setLogTimeZone("GMT");
RequestLogHandler requestLogHandler = new RequestLogHandler();
requestLogHandler.setRequestLog(requestLog);
handlers.addHandler(requestLogHandler);
```

Now when it starts up it gives you among other things the following:

```
2014-09-24 15:04:53.360:INFO:oejs.AbstractNCSARequestLog:main: Opened /private/tmp/2014_09_24.request.log
2014-09-24 15:04:53.373:INFO:oejs.ServerConnector:main: Started ServerConnector@1c466919{HTTP/1.1}{0.0.0.0:8080}
```

That `/tmp/2014_09_24.request.log` file contains the following line after a single hit from my web browser:
 
```
0:0:0:0:0:0:0:1 -  -  [24/Sep/2014:22:04:55 +0000] "GET / HTTP/1.1" 200 - "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.122 Safari/537.36"
```

## Servlets

We will primarily use jetty as a servlet container.  It serves servlets using a handler called `ServletHandler`.

Jetty requires a mapping from the URL to servlet.


### GET

Note that the servlet receives a request and response object.  The request object contains information about the HTTP request, plus parameters, and other header info.  The response object lets you set response headers, cookies, and lets you write to the output stream.

```java
// Derived from:
// http://download.eclipse.org/jetty/stable-9/xref/org/eclipse/jetty/embedded/FileServer.html
// Copyright (c) 1995-2014 Mort Bay Consulting Pty. Ltd.
// Released under Eclipse Public License v1.0 and Apache License v2.0

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletHandler;

public class MinimalServlets {
    public static void main(String[] args) throws Exception {
        // Create a basic jetty server object that will listen on port 8080.  Note that if you set this to port 0
        // then a randomly available port will be assigned that you can either look in the logs for the port,
        // or programmatically obtain it for use in test cases.
        Server server = new Server(8080);

        // The ServletHandler is a dead simple way to create a context handler that is backed by an instance of a
        // Servlet.  This handler then needs to be registered with the Server object.
        ServletHandler handler = new ServletHandler();
        server.setHandler(handler);

        // Passing in the class for the servlet allows jetty to instantite an instance of that servlet and mount it
        // on a given context path.

        // !! This is a raw Servlet, not a servlet that has been configured through a web.xml or anything like that !!
        handler.addServletWithMapping(HelloServlet.class, "/*");
        handler.addServletWithMapping(SimpleResponseServlet.class, "/servlet/SimpleResponse");

        // Start things up! By using the server.join() the server thread will join with the current thread.
        // See "http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Thread.html#join()" for more details.
        server.start();
        server.join();
    }
}
```

```bash
java -cp ".:/usr/local/lib/jetty-9.2.3/*" MinimalServlets
```

If you go to any directory at localhost:8080, you should see `Hello SimpleServlet`.

### POST

Used as target of form processing.  Can handle much more data (I think) in terms of parameters.  `request.getParameter` is used to get URL parameters.

```html
<html>
<body>
<FORM METHOD=POST ACTION="/servlet/SimpleResponse">
<input type=text size=45 name=query value="type your query here">
<input type=submit value=SEARCH>
</FORM>
</body>
</html>
```

Servlet responding to form (note both `doGet` and `doPost` methods):

```java
```

You can actually wire `doGet` to `doPost` as they are more or less same thing.

Use HttpUtils.getRequestURL(request) to reconstruct URL minus query (args).

Other useful methods in: [getRemoteHost()](http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getRemoteHost()

## Multiple connectors

A `Connector` in jetty terminology is something sitting on a port that will invoke a handler upon requests to that port. When we create a `Server(8080)` it automatically creates an HTTP connection at 8080.

Sometimes we want more than one connector, such as for HTTP and HTTPS. You can go take a look at the [`ManyConnectors.java`](http://download.eclipse.org/jetty/stable-9/xref/org/eclipse/jetty/embedded/ManyConnectors.html) example from jetty that demonstrates SSL/HTTPS connections.

## Multiple URL context

 It's often the case that we want to serve static pages as well as invoke Java code. Jetty supports the notion of context for this. From their documentation, here's a way to serve static files under `/tmp` and create servlets complete with sessions and so on everywhere else:

```java
Server server = new Server(8080);
ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
context.setContextPath("/");
server.setHandler(context);

context.addServlet(org.eclipse.jetty.servlet.DefaultServlet.class,"/");
context.addServlet(new ServletHolder(new DumpServlet()),"/dump/*");
```

# Thread safety

The safety issue for servlets with instance variables can be illustrated with the following:

```java
class PageServlet extends HttpServlet {
    String id;
    public void doGet(HttpServletRequest request,
          HttpServletResponse response)
    throws ServletException, IOException
    {
        id = request.getParameter("ID");
        ...
        out.println("Your id is "+id);
    }
    ...
}
```

One thread can set the `id` then switch to another thread which resets id.  When that second thread finishes the first thread would start up and proceed to print out the same value as the second thread.  I.e., if url `/foo?ID=1` and `/foo/?ID=2` result in simultaneous exec of this servlet, you risk seeing the same id value printed out. (Assuming `/foo` is how we have mapped to the servlet.)

# File Uploads

Can do file uploads with http servers.  The HTML POST action looks like:

```html
<FORM METHOD=POST ACTION="/submit/process" ENCTYPE="multipart/form-data">
...
</FORM>
```

# Argument URL encoding

Converts meaningful or special chars to ascii code.

`' '->%20` etc....

Use:  `java.netURLEncoder.encode(...)`

Here is an example calling the doGet method using a space in arg.

http://localhost:8080/servlet/SimpleResponse?name=Terence%20Parr

